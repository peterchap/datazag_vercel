import type { Express, Request, Response, NextFunction } from "express";
import { createServer, type Server } from "http";
import { storage as dbStorage } from "./storage";
import passport from "passport";
import Stripe from "stripe";
import multer from "multer";
import path from "path";
import fs from "fs";
import { setupAuth } from "./auth";
import {
  insertApiKeySchema,
  insertTransactionSchema,
  insertApiUsageSchema,
  insertAdminRequestSchema,
  insertSubscriptionPlanSchema,
  insertUserSubscriptionSchema,
  User,
  USER_ROLES,
  ADMIN_REQUEST_STATUS,
  SUBSCRIPTION_INTERVALS
} from "@shared/schema";
import { createPaypalOrder, capturePaypalOrder, loadPaypalDefault } from "./paypal";
import { z } from "zod";
import { notificationService } from "./notifications";

declare global {
  namespace Express {
    interface User {
      id: number;
      username: string;
      email: string;
      company?: string;
      credits: number;
      stripeCustomerId?: string;
      role: string;
      parentUserId?: number;
      canPurchaseCredits?: boolean;
      gracePeriodEnd?: Date | null;
      creditThreshold?: number | null;
    
  


// Check for Stripe API key
if (!process.env.STRIPE_SECRET_KEY) {
  console.warn("Missing STRIPE_SECRET_KEY environment variable. Stripe integration will be disabled.");
} else {
  console.log("Stripe integration enabled. Using API key:", process.env.STRIPE_SECRET_KEY.substring(0, 8) + "...");


// Initialize Stripe if key is available
const stripeApiKey = process.env.STRIPE_SECRET_KEY || '';
const stripe = stripeApiKey 
  ? new Stripe(stripeApiKey, { apiVersion: "2023-10-16" })
  : undefined;

export async function registerRoutes(app: Express): Promise<Server> {
  // Schema for credit control endpoints
  const setCreditControlSchema = z.object({
    userId: z.number(),
    canPurchaseCredits: z.boolean()
  });
  
  const setCreditThresholdSchema = z.object({
    userId: z.number(),
    threshold: z.number().nullable()
  });
  
  const setGracePeriodSchema = z.object({
    userId: z.number(),
    days: z.number().nullable()
  });
  // Set up file upload directory
  const uploadDir = path.join(process.cwd(), 'uploads');
  
  // Create the uploads directory if it doesn't exist
  if (!fs.existsSync(uploadDir)) {
    fs.mkdirSync(uploadDir, { recursive: true });
  
  
  // Configure multer storage for file uploads
  const storage = multer.diskStorage({
    destination: (req, file, cb) => {
      cb(null, uploadDir);
    },
    filename: (req, file, cb) => {
      // Generate a unique filename with the original extension
      const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
      const ext = path.extname(file.originalname);
      cb(null, file.fieldname + '-' + uniqueSuffix + ext);
    
  });
  
  // Define file upload limits
  const upload = multer({ 
    storage: storage,
    limits: {
      fileSize: 10 * 1024 * 1024, // 10MB limit
    
  });
  // API endpoint to provide default exchange rates
  app.get("/api/exchange-rates", async (req, res) => {
    try {
      if (!stripe) {
        throw new Error("Stripe is not configured");
      

      // Since we're having issues with Stripe's API, let's use hard-coded 
      // reasonable exchange rates for now to make the currency selector work
      const rates: { [key: string]: number } = {
        USD: 1.0, // Base currency
        EUR: 0.93, // 1 USD ≈ 0.93 EUR
        GBP: 0.79, // 1 USD ≈ 0.79 GBP
        JPY: 155.0, // 1 USD ≈ 155 JPY
        CAD: 1.36, // 1 USD ≈ 1.36 CAD
        AUD: 1.52, // 1 USD ≈ 1.52 AUD
        CHF: 0.91, // 1 USD ≈ 0.91 CHF
        CNY: 7.23, // 1 USD ≈ 7.23 CNY
        INR: 83.5, // 1 USD ≈ 83.5 INR
        SGD: 1.35, // 1 USD ≈ 1.35 SGD (Singapore Dollar)
        ZAR: 18.61, // 1 USD ≈ 18.61 ZAR (South African Rand)
        NZD: 1.64 // 1 USD ≈ 1.64 NZD (New Zealand Dollar)
      };
      
      // In production, this would use:
      // const quote = await stripe.quotes.create({
      //   currency: 'usd',
      //   line_items: [
      //     { price: 'price_xxx', quantity: 1 
      //   ],
      //   fx_rate_denom: currencies.join(',')
      // });
      
      res.json(rates);
    } catch (error: any) {
      console.error("Error providing exchange rates:", error);
      res.status(500).json({ 
        message: "Failed to provide exchange rates", 
        error: error.message 
      });
    
  });
  
  // Diagnostic endpoint to help with debugging connectivity issues
  app.get("/api/debug/connection-test", (req, res) => {
    // Get basic information about the request and session
    res.json({
      timestamp: new Date().toISOString(),
      requestInfo: {
        remoteAddress: req.socket.remoteAddress,
        remotePort: req.socket.remotePort,
        headers: req.headers,
        ip: req.ip,
        originalUrl: req.originalUrl,
        protocol: req.protocol,
        secure: req.secure,
        hostname: req.hostname,
      },
      sessionInfo: {
        sessionID: req.sessionID,
        cookie: req.session?.cookie,
        isAuthenticated: req.isAuthenticated(),
      
    });
  });
  // Set up authentication with our custom implementation
  setupAuth(app);

  // Authentication middleware
  const isAuthenticated = (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    
    
    if (!req.user) {
      return res.status(403).json({ message: "Forbidden: User session invalid" });
    
    
    return next();
  };

  // Profile routes
  app.patch("/api/profile", isAuthenticated, async (req, res) => {
    try {
      const allowedFields = ["email", "company"];
      const filteredData: Partial<User> = {};
      
      for (const field of allowedFields) {
        if (req.body[field] !== undefined) {
          filteredData[field as keyof User] = req.body[field];
        
      
      
      const updatedUser = await dbStorage.updateUser(req.user!.id, filteredData);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      
      
      const { password, ...userWithoutPassword } = updatedUser;
      res.json(userWithoutPassword);
    } catch (error) {
      res.status(500).json({ message: "Error updating profile" });
    
  });

  // Credit bundle routes
  app.get("/api/credit-bundles", async (req, res) => {
    try {
      const bundles = await dbStorage.getCreditBundles();
      res.json(bundles);
    } catch (error) {
      res.status(500).json({ message: "Error fetching credit bundles" });
    
  });

  // API key routes
  app.get("/api/api-keys", isAuthenticated, async (req, res) => {
    try {
      const apiKeys = await dbStorage.getApiKeysByUserId(req.user!.id);
      res.json(apiKeys);
    } catch (error) {
      res.status(500).json({ message: "Error fetching API keys" });
    
  });

  app.post("/api/api-keys", isAuthenticated, async (req, res) => {
    try {
      const validatedData = insertApiKeySchema.parse(req.body);
      
      const apiKey = await dbStorage.createApiKey({
        ...validatedData,
        userId: req.user!.id,
      });
      
      // Add transaction record for API key creation
      await dbStorage.createTransaction({
        userId: req.user!.id,
        type: "info",
        amount: 0,
        description: `API key generated: ${validatedData.name}`,
        apiKeyId: apiKey.id,
        status: "success",
        metadata: null,
      });
      
      res.status(201).json(apiKey);
    } catch (error) {
      if (error instanceof z.ZodError) {
        res.status(400).json({ message: error.errors });
      } else {
        res.status(500).json({ message: "Error creating API key" });
      
    
  });

  app.delete("/api/api-keys/:id", isAuthenticated, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid API key ID" });
      
      
      const apiKey = await dbStorage.getApiKey(id);
      if (!apiKey) {
        return res.status(404).json({ message: "API key not found" });
      
      
      if (apiKey.userId !== req.user!.id) {
        return res.status(403).json({ message: "Forbidden" });
      
      
      const deactivatedApiKey = await dbStorage.deactivateApiKey(id);
      res.json(deactivatedApiKey);
    } catch (error) {
      res.status(500).json({ message: "Error deactivating API key" });
    
  });

  // File upload endpoints
  app.post("/api/upload/single", isAuthenticated, upload.single("file"), async (req, res) => {
    try {
      if (!req.file) {
        return res.status(400).json({ message: "No file uploaded" });
      
      
      // Define credit cost for single file processing
      const creditCost = 1;
      
      // Check if user has enough credits
      if (req.user!.credits < creditCost) {
        // Remove uploaded file if user doesn't have enough credits
        fs.unlinkSync(req.file.path);
        return res.status(402).json({ message: "Insufficient credits" });
      
      
      // Use credits
      await dbStorage.useCredits(req.user!.id, creditCost);
      
      // Record transaction
      await dbStorage.createTransaction({
        userId: req.user!.id,
        type: "usage",
        amount: -creditCost,
        description: "Single file upload processing",
        apiKeyId: null,
        status: "success",
        metadata: {
          originalName: req.file.originalname,
          mimetype: req.file.mimetype,
          size: req.file.size
        },
      });
      
      // Notify admins about the file upload
      const { notificationService } = await import('./notifications');
      await notificationService.notifyAdmins(
        `User ${req.user!.username} uploaded a file: ${req.file.originalname}`,
        'info',
        {
          relatedEntityType: 'file',
          link: `/admin/files`
        
      );
      
      // Return file details
      res.json({
        message: "File uploaded successfully",
        file: {
          filename: req.file.filename,
          originalname: req.file.originalname,
          mimetype: req.file.mimetype,
          size: req.file.size
        },
        credits_used: creditCost,
        credits_remaining: req.user!.credits - creditCost
      });
    } catch (error: any) {
      res.status(500).json({ message: "Error processing file", error: error.message });
    
  });
  
  app.post("/api/upload/bulk", isAuthenticated, upload.array("files", 10), async (req, res) => {
    try {
      if (!req.files || (Array.isArray(req.files) && req.files.length === 0)) {
        return res.status(400).json({ message: "No files uploaded" });
      
      
      // Define credit cost per file
      const creditCostPerFile = 0.5;
      const files = req.files as Express.Multer.File[];
      const totalCreditCost = Math.ceil(files.length * creditCostPerFile);
      
      // Check if user has enough credits
      if (req.user!.credits < totalCreditCost) {
        // Remove all uploaded files if user doesn't have enough credits
        files.forEach(file => {
          fs.unlinkSync(file.path);
        });
        return res.status(402).json({ message: "Insufficient credits" });
      
      
      // Use credits
      await dbStorage.useCredits(req.user!.id, totalCreditCost);
      
      // Record transaction
      await dbStorage.createTransaction({
        userId: req.user!.id,
        type: "usage",
        amount: -totalCreditCost,
        description: `Bulk file upload processing (${files.length} files)`,
        apiKeyId: null,
        status: "success",
        metadata: {
          fileCount: files.length
        },
      });
      
      // Notify admins about the bulk file upload
      const { notificationService } = await import('./notifications');
      await notificationService.notifyAdmins(
        `User ${req.user!.username} uploaded ${files.length} files in bulk`,
        'info',
        {
          relatedEntityType: 'file',
          link: `/admin/files`
        
      );
      
      // Return files details
      res.json({
        message: "Files uploaded successfully",
        files: files.map(file => ({
          filename: file.filename,
          originalname: file.originalname,
          mimetype: file.mimetype,
          size: file.size
        })),
        files_count: files.length,
        credits_used: totalCreditCost,
        credits_remaining: req.user!.credits - totalCreditCost
      });
    } catch (error: any) {
      res.status(500).json({ message: "Error processing files", error: error.message });
    
  });
  
  // Transaction routes
  app.get("/api/transactions", isAuthenticated, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const transactions = await dbStorage.getTransactions(req.user!.id, limit);
      res.json(transactions);
    } catch (error) {
      res.status(500).json({ message: "Error fetching transactions" });
    
  });

  // API usage routes
  app.get("/api/api-usage", isAuthenticated, async (req, res) => {
    try {
      const limit = req.query.limit ? parseInt(req.query.limit as string) : undefined;
      const apiUsage = await dbStorage.getApiUsage(req.user!.id, limit);
      res.json(apiUsage);
    } catch (error) {
      res.status(500).json({ message: "Error fetching API usage" });
    
  });
  
  // Notifications routes
  app.get("/api/notifications", isAuthenticated, async (req, res) => {
    try {
      const { notificationService } = await import('./notifications');
      const includeRead = req.query.includeRead === 'true';
      const limit = req.query.limit ? parseInt(req.query.limit as string) : 10;
      
      const notifications = notificationService.getForUser(req.user!.id, limit, includeRead);
      res.json(notifications);
    } catch (error: any) {
      res.status(500).json({ message: "Error fetching notifications", error: error.message });
    
  });
  
  app.post("/api/notifications/:id/read", isAuthenticated, async (req, res) => {
    try {
      const { notificationService } = await import('./notifications');
      const id = parseInt(req.params.id);
      
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid notification ID" });
      
      
      const success = notificationService.markAsRead(id);
      if (success) {
        res.json({ message: "Notification marked as read" });
      } else {
        res.status(404).json({ message: "Notification not found" });
      
    } catch (error: any) {
      res.status(500).json({ message: "Error marking notification as read", error: error.message });
    
  });
  
  app.post("/api/notifications/read-all", isAuthenticated, async (req, res) => {
    try {
      const { notificationService } = await import('./notifications');
      const count = notificationService.markAllAsRead(req.user!.id);
      res.json({ message: `${count} notifications marked as read` });
    } catch (error: any) {
      res.status(500).json({ message: "Error marking notifications as read", error: error.message });
    
  });

  // Example API endpoint that consumes credits
  app.post("/api/query", async (req, res) => {
    try {
      const apiKey = req.headers.authorization?.split(" ")[1];
      if (!apiKey) {
        return res.status(401).json({ message: "API key is required" });
      
      
      const apiKeyRecord = await dbStorage.getApiKeyByKey(apiKey);
      if (!apiKeyRecord) {
        return res.status(401).json({ message: "Invalid API key" });
      
      
      if (!apiKeyRecord.isActive) {
        return res.status(401).json({ message: "API key is inactive" });
      
      
      const user = await dbStorage.getUser(apiKeyRecord.userId);
      if (!user) {
        return res.status(401).json({ message: "User not found" });
      
      
      // Define credit cost for this API endpoint
      const creditCost = 3;
      
      // Check if user has enough credits
      if (user.credits < creditCost) {
        return res.status(402).json({ message: "Insufficient credits" });
      
      
      // Use credits
      const success = await dbStorage.useCredits(user.id, creditCost);
      if (!success) {
        return res.status(402).json({ message: "Error using credits" });
      
      
      // Record API usage
      const startTime = Date.now();
      
      // Simulate API response
      const responseTime = Date.now() - startTime;
      
      await dbStorage.createApiUsage({
        userId: user.id,
        apiKeyId: apiKeyRecord.id,
        endpoint: "/api/query",
        credits: creditCost,
        status: "success",
        responseTime,
      });
      
      // Record transaction
      await dbStorage.createTransaction({
        userId: user.id,
        type: "usage",
        amount: -creditCost,
        description: "Database query",
        apiKeyId: apiKeyRecord.id,
        status: "success",
        metadata: {
          endpoint: "/api/query",
          responseTime,
        },
      });
      
      // Return actual API response
      res.json({
        success: true,
        message: "Query executed successfully",
        credits_used: creditCost,
        credits_remaining: user.credits - creditCost,
      });
    } catch (error) {
      res.status(500).json({ message: "Error processing API request" });
    
  });

  // Discount code endpoint
  app.post("/api/validate-discount", isAuthenticated, async (req, res) => {
    try {
      const { code, amount } = req.body;
      
      if (!code || !amount) {
        return res.status(400).json({ message: "Discount code and amount are required" });
      

      const result = await dbStorage.validateDiscountCode(code, amount);
      res.json(result);
    } catch (error: any) {
      console.error("Error validating discount code:", error);
      res.status(500).json({ message: error.message });
    
  });

  // Stripe payment routes
  if (stripe) {
    app.post("/api/create-payment-intent", isAuthenticated, async (req, res) => {
      try {
        const { bundleId, discountCode } = req.body;
        
        if (!bundleId) {
          return res.status(400).json({ message: "Bundle ID is required" });
        
        
        // First check if user is allowed to purchase credits
        const user = await dbStorage.getUser(req.user!.id);
        if (user && user.canPurchaseCredits === false) {
          return res.status(403).json({ 
            message: "Credit purchases are disabled for your account. Please contact your administrator."
          });
        
        
        const bundle = await dbStorage.getCreditBundle(bundleId);
        if (!bundle) {
          return res.status(404).json({ message: "Credit bundle not found" });
        
        
        // Calculate final price with discount if applicable
        let finalPrice = bundle.price;
        let appliedDiscount = null;
        
        if (discountCode) {
          const validationResult = await dbStorage.validateDiscountCode(discountCode, bundle.price);
          if (validationResult.isValid && validationResult.discountCode) {
            finalPrice = bundle.price - validationResult.discountAmount;
            appliedDiscount = {
              code: discountCode,
              discountAmount: validationResult.discountAmount,
              originalPrice: bundle.price,
              finalPrice: finalPrice
            };
          
        
        
        // Create a PaymentIntent with the order amount and currency
        const paymentIntent = await stripe.paymentIntents.create({
          amount: finalPrice,
          currency: "usd",
          metadata: {
            bundleId: bundle.id.toString(),
            userId: req.user!.id.toString(),
            credits: bundle.credits.toString(),
            discountCode: discountCode || "",
          },
        });
        
        res.json({
          clientSecret: paymentIntent.client_secret,
          bundleDetails: bundle,
          appliedDiscount
        });
      } catch (error: any) {
        console.error("Error creating payment intent:", error);
        res.status(500).json({ message: `Error creating payment intent: ${error.message}` });
      
    });
    
    app.post("/api/payment-success", isAuthenticated, async (req, res) => {
      try {
        const { paymentIntentId } = req.body;
        
        if (!paymentIntentId) {
          return res.status(400).json({ message: "Payment intent ID is required" });
        
        
        // Verify the payment intent with Stripe
        const paymentIntent = await stripe.paymentIntents.retrieve(paymentIntentId);
        
        if (paymentIntent.status !== "succeeded") {
          return res.status(400).json({ message: "Payment has not succeeded" });
        
        
        // Extract metadata
        const bundleId = parseInt(paymentIntent.metadata.bundleId);
        const userId = parseInt(paymentIntent.metadata.userId);
        const credits = parseInt(paymentIntent.metadata.credits);
        const discountCode = paymentIntent.metadata.discountCode;
        
        // Verify user matches the authenticated user
        if (userId !== req.user!.id) {
          return res.status(403).json({ message: "Forbidden" });
        
        
        // Get the bundle details
        const bundle = await dbStorage.getCreditBundle(bundleId);
        if (!bundle) {
          return res.status(404).json({ message: "Credit bundle not found" });
        

        // Handle discount code if one was used
        let appliedDiscount = null;
        if (discountCode) {
          const discountCodeRecord = await dbStorage.getDiscountCodeByCode(discountCode);
          if (discountCodeRecord) {
            // Increment usage count
            await dbStorage.incrementDiscountCodeUsage(discountCodeRecord.id);
            
            // Get the final validation result to include in the metadata
            const validationResult = await dbStorage.validateDiscountCode(discountCode, bundle.price);
            if (validationResult.isValid) {
              appliedDiscount = {
                code: discountCode,
                discountAmount: validationResult.discountAmount,
                originalPrice: bundle.price,
                finalPrice: bundle.price - validationResult.discountAmount
              };
            
          
        
        
        // Add credits to user account
        const updatedUser = await dbStorage.addCredits(userId, credits);
        if (!updatedUser) {
          return res.status(404).json({ message: "User not found" });
        
        
        // Update the user in the session to reflect the new credit balance
        if (req.user) {
          req.user.credits = updatedUser.credits;
        
        
        // Record transaction
        await dbStorage.createTransaction({
          userId,
          type: "purchase",
          amount: credits,
          description: `Credit purchase: ${bundle.name}${discountCode ? ` with discount code ${discountCode}` : ''}`,
          status: "success",
          apiKeyId: null,
          metadata: {
            bundleId,
            paymentIntentId,
            amount: paymentIntent.amount, // This is the actual amount charged (with discount applied)
            originalAmount: bundle.price,
            discount: appliedDiscount,
            paymentMethod: "stripe"
          },
        });
        
        // Log the credit update
        console.log(`Credits updated: User ${userId} now has ${updatedUser.credits} credits (+${credits})`);
        
        res.json({
          success: true,
          credits: updatedUser.credits,
          added: credits,
        });
      } catch (error: any) {
        console.error("Error processing payment success:", error);
        res.status(500).json({ message: `Error processing payment: ${error.message}` });
      
    });
    
    // PayPal payment success handler for credit purchases
    app.post("/api/paypal-payment-success", isAuthenticated, async (req, res) => {
      try {
        const { orderID, bundleId } = req.body;
        
        if (!orderID || !bundleId) {
          return res.status(400).json({ 
            message: "Order ID and bundle ID are required" 
          });
        
        
        const userId = req.user!.id;
        
        // Get the bundle details
        const bundle = await dbStorage.getCreditBundle(parseInt(bundleId));
        if (!bundle) {
          return res.status(404).json({ message: "Credit bundle not found" });
        
        
        // Handle discount code if one was provided
        const discountCode = req.body.discountCode;
        let appliedDiscount = null;
        let finalPrice = bundle.price;
        
        if (discountCode) {
          const discountCodeRecord = await dbStorage.getDiscountCodeByCode(discountCode);
          if (discountCodeRecord) {
            // Increment usage count
            await dbStorage.incrementDiscountCodeUsage(discountCodeRecord.id);
            
            // Get the final validation result to include in the metadata
            const validationResult = await dbStorage.validateDiscountCode(discountCode, bundle.price);
            if (validationResult.isValid) {
              appliedDiscount = {
                code: discountCode,
                discountAmount: validationResult.discountAmount,
                originalPrice: bundle.price,
                finalPrice: bundle.price - validationResult.discountAmount
              };
              finalPrice = bundle.price - validationResult.discountAmount;
            
          
        
        
        // Add credits to user account
        const updatedUser = await dbStorage.addCredits(userId, bundle.credits);
        if (!updatedUser) {
          return res.status(404).json({ message: "User not found" });
        
        
        // Update the user in the session to reflect the new credit balance
        if (req.user) {
          req.user.credits = updatedUser.credits;
        
        
        // Record transaction
        await dbStorage.createTransaction({
          userId,
          type: "purchase",
          amount: bundle.credits,
          description: `Credit purchase: ${bundle.name}${discountCode ? ` with discount code ${discountCode}` : ''}`,
          status: "success",
          apiKeyId: null,
          metadata: {
            bundleId,
            paypalOrderId: orderID,
            amount: finalPrice / 100, // Convert from cents to dollars for consistency with PayPal
            originalAmount: bundle.price,
            discount: appliedDiscount,
            paymentMethod: "paypal"
          },
        });
        
        // Log the credit update
        console.log(`Credits updated via PayPal: User ${userId} now has ${updatedUser.credits} credits (+${bundle.credits})`);
        
        res.json({
          success: true,
          credits: updatedUser.credits,
          added: bundle.credits,
        });
      } catch (error: any) {
        console.error("Error processing PayPal payment success:", error);
        res.status(500).json({ message: `Error processing PayPal payment: ${error.message}` });
      
    });
  

  // Admin middleware for any type of admin
  const isAdmin = (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    
    
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: "Forbidden: User has no role assigned" });
    
    
    // Check if user has any admin role
    if (req.user.role === USER_ROLES.BUSINESS_ADMIN || req.user.role === USER_ROLES.CLIENT_ADMIN) {
      return next();
    
    
    return res.status(403).json({ message: "Forbidden: Admin access required" });
  };
  
  // Business Admin middleware - only business admins can access
  const isBusinessAdmin = (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    
    
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: "Forbidden: User has no role assigned" });
    
    
    // Check if user has business admin role
    if (req.user.role === USER_ROLES.BUSINESS_ADMIN) {
      return next();
    
    
    return res.status(403).json({ message: "Forbidden: Business admin access required" });
  };
  
  // Client Admin middleware - checks if user is a client admin or business admin
  const isClientAdmin = (req: Request, res: Response, next: NextFunction) => {
    if (!req.isAuthenticated()) {
      return res.status(401).json({ message: "Unauthorized" });
    
    
    if (!req.user || !req.user.role) {
      return res.status(403).json({ message: "Forbidden: User has no role assigned" });
    
    
    // Business admins have full access to everything
    if (req.user.role === USER_ROLES.BUSINESS_ADMIN) {
      return next();
    
    
    // Client admins can only access their own data and data of users with them as a parent
    if (req.user.role === USER_ROLES.CLIENT_ADMIN) {
      // If there's a user ID in the params, check if this client admin can access it
      const requestedUserId = req.params.userId || req.params.id;
      
      if (requestedUserId) {
        const userId = parseInt(requestedUserId);
        
        // If accessing their own data, allow it
        if (userId === req.user.id) {
          return next();
        
        
        // Otherwise, check if the requested user has this admin as parent
        // This is an async check that needs to be handled
        dbStorage.getUser(userId)
          .then(user => {
            if (!user) {
              return res.status(404).json({ message: "User not found" });
            
            
            // Check if this admin is the parent of the requested user
            if (user.parentUserId === req.user.id) {
              return next();
            } else {
              return res.status(403).json({ 
                message: "Forbidden: You do not have permission to access this user's data" 
              });
            
          })
          .catch(error => {
            return res.status(500).json({ message: "Error checking user permissions" });
          });
        
        // Return here since we're handling the response in the Promise
        return;
      
      
      // If not accessing a specific user's data (e.g., getting list of discount codes),
      // allow client admin access
      return next();
    
    
    return res.status(403).json({ message: "Forbidden: Client admin access required" });
  };

  // ===== ADMIN ROUTES =====
  
  // Admin - Discount Codes
  app.get("/api/admin/discount-codes", isClientAdmin, async (req, res) => {
    try {
      const discountCodes = await dbStorage.getDiscountCodes();
      res.json(discountCodes);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.post("/api/admin/discount-codes", isBusinessAdmin, async (req, res) => {
    try {
      const discountCode = await dbStorage.createDiscountCode(req.body);
      res.status(201).json(discountCode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.get("/api/admin/discount-codes/:id", isClientAdmin, async (req, res) => {
    try {
      const discountCode = await dbStorage.getDiscountCode(parseInt(req.params.id));
      if (!discountCode) {
        return res.status(404).json({ message: "Discount code not found" });
      
      res.json(discountCode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.patch("/api/admin/discount-codes/:id", isBusinessAdmin, async (req, res) => {
    try {
      const discountCode = await dbStorage.updateDiscountCode(parseInt(req.params.id), req.body);
      if (!discountCode) {
        return res.status(404).json({ message: "Discount code not found" });
      
      res.json(discountCode);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.delete("/api/admin/discount-codes/:id", isBusinessAdmin, async (req, res) => {
    try {
      const success = await dbStorage.deleteDiscountCode(parseInt(req.params.id));
      if (!success) {
        return res.status(404).json({ message: "Discount code not found" });
      
      res.json({ message: "Discount code deleted successfully" });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  // Admin - User Management
  app.get("/api/admin/users", isClientAdmin, async (req, res) => {
    try {
      let users = await dbStorage.getAllUsers();
      
      // Filter users based on admin role
      if (req.user!.role === USER_ROLES.CLIENT_ADMIN) {
        // Client admins can only see themselves and users with them as parent
        users = users.filter(user => 
          user.id === req.user!.id || user.parentUserId === req.user!.id
        );
      
      // Business admins can see all users (no filtering needed)
      
      res.json(users);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });
  
  // Credit management endpoints
  
  // Control whether a user can purchase credits (for client admins)
  app.post("/api/admin/users/:userId/credit-control", isClientAdmin, async (req, res) => {
    try {
      const result = setCreditControlSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: "Invalid request data", errors: result.error.format() });
      
      
      const { userId, canPurchaseCredits } = result.data;
      
      // Additional validation to ensure userId in body matches URL param
      if (userId !== parseInt(req.params.userId)) {
        return res.status(400).json({ message: "User ID mismatch between URL and request body" });
      
      
      // Update the user's credit purchase permission
      const updatedUser = await dbStorage.setCanPurchaseCredits(userId, canPurchaseCredits);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      
      
      // Notify the user about the change
      const adminName = req.user?.username || 'An administrator';
      
      await notificationService.createForUser(
        userId,
        `Your credit purchase ability has been ${canPurchaseCredits ? 'enabled' : 'disabled'} by ${adminName}`,
        canPurchaseCredits ? 'success' : 'warning',
        {
          relatedEntityType: 'user_setting',
          link: '/profile'
        
      );
      
      res.json({
        message: `User credit purchase ability ${canPurchaseCredits ? 'enabled' : 'disabled'} successfully`,
        user: updatedUser
      });
    } catch (error: any) {
      console.error("Error in credit control endpoint:", error);
      res.status(500).json({ message: "Server error", error: error.message });
    
  });
  
  // Set credit threshold for low balance notification
  app.post("/api/admin/users/:userId/credit-threshold", isClientAdmin, async (req, res) => {
    try {
      const result = setCreditThresholdSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: "Invalid request data", errors: result.error.format() });
      
      
      const { userId, days } = result.data;
      
      // Additional validation to ensure userId in body matches URL param
      if (userId !== parseInt(req.params.userId)) {
        return res.status(400).json({ message: "User ID mismatch between URL and request body" });
      
      
      // Update the user's grace period
      const updatedUser = await dbStorage.setGracePeriod(userId, days);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      
      
      // Notify the user about the change
      const adminName = req.user?.username || 'An administrator';
      
      await notificationService.createForUser(
        userId,
        `Your grace period has been ${days === null ? 'removed' : `set to ${days} days`} by ${adminName}`,
        'info',
        {
          relatedEntityType: 'user_setting',
          link: '/profile'
        
      );
      
      res.json({
        message: `User grace period ${days === null ? 'removed' : `set to ${days} days`} successfully`,
        user: updatedUser
      });
    } catch (error: any) {
      console.error("Error in credit threshold endpoint:", error);
      res.status(500).json({ message: "Server error", error: error.message });
    
  });
  
  // Endpoint for checking a user's current credit threshold status
  app.get("/api/admin/users/:userId/credit-threshold", isClientAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const thresholdStatus = await dbStorage.checkCreditThreshold(userId);
      
      if (!thresholdStatus) {
        return res.status(404).json({ message: "User not found" });
      
      
      res.json(thresholdStatus);
      
      
      // Update the user's credit threshold
      const updatedUser = await dbStorage.setCreditThreshold(userId, threshold);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      
      
      // After setting threshold, check if user is already below it
      const thresholdStatus = await dbStorage.checkCreditThreshold(userId);
      
      // If below threshold, send alert immediately
      if (threshold !== null && thresholdStatus.belowThreshold) {
        try {
          await notificationService.sendLowCreditAlert(
            updatedUser,
            thresholdStatus.currentCredits,
            thresholdStatus.threshold || 0,
            thresholdStatus.thresholdPercentage || 10
          );
        } catch (alertError) {
          console.error("Failed to send low credit alert:", alertError);
          // Continue even if alert fails
        
      
      
      res.json({
        message: threshold === null 
          ? "Credit threshold removed successfully" 
          : `Credit threshold set to ${threshold} credits successfully`,
        user: updatedUser,
        thresholdStatus
      });
    } catch (error: any) {
      console.error("Error in credit threshold endpoint:", error);
      res.status(500).json({ message: "Server error", error: error.message });
    
  });
  
  // Set grace period for payment failures
  app.post("/api/admin/users/:userId/grace-period", isClientAdmin, async (req, res) => {
    try {
      const result = setGracePeriodSchema.safeParse(req.body);
      if (!result.success) {
        return res.status(400).json({ message: "Invalid request data", errors: result.error.format() });
      
      
      const { userId, days } = result.data;
      
      // Additional validation to ensure userId in body matches URL param
      if (userId !== parseInt(req.params.userId)) {
        return res.status(400).json({ message: "User ID mismatch between URL and request body" });
      
      
      // Update the user's grace period
      const updatedUser = await dbStorage.setGracePeriod(userId, days);
      if (!updatedUser) {
        return res.status(404).json({ message: "User not found" });
      
      
      // Notify the user about the grace period
      if (updatedUser.email && days !== null) {
        try {
          const gracePeriodEnd = updatedUser.gracePeriodEnd;
          const formattedDate = gracePeriodEnd 
            ? new Date(gracePeriodEnd).toLocaleDateString('en-US', {
                year: 'numeric',
                month: 'long',
                day: 'numeric'
              })
            : 'N/A';
          
          await notificationService.createForUser(
            userId,
            `A grace period of ${days} days has been granted for your account until ${formattedDate}`,
            'info',
            {
              relatedEntityType: 'payments',
              link: '/settings'
            
          );
        } catch (notifyError) {
          console.error("Failed to create notification:", notifyError);
          // Continue even if notification fails
        
      
      
      res.json({
        message: days === null 
          ? "Grace period removed successfully" 
          : `Grace period of ${days} days set successfully`,
        user: updatedUser,
        hasActiveGracePeriod: days !== null
      });
    } catch (error: any) {
      console.error("Error in grace period endpoint:", error);
      res.status(500).json({ message: "Server error", error: error.message });
    
  });

  app.get("/api/admin/users/:id", isClientAdmin, async (req, res) => {
    try {
      const user = await dbStorage.getUser(parseInt(req.params.id));
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });
  
  // Admin - User API Keys
  app.get("/api/admin/users/:userId/api-keys", isClientAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const user = await dbStorage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      
      
      const apiKeys = await dbStorage.getApiKeysByUserId(userId);
      res.json(apiKeys);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });
  
  app.post("/api/admin/users/:userId/api-keys", isClientAdmin, async (req, res) => {
    try {
      const userId = parseInt(req.params.userId);
      const user = await dbStorage.getUser(userId);
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      
      
      const apiKey = await dbStorage.createApiKey({
        userId,
        name: req.body.name,
        isActive: true,
      });
      
      res.status(201).json(apiKey);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });
  
  app.patch("/api/admin/api-keys/:keyId", isClientAdmin, async (req, res) => {
    try {
      const keyId = parseInt(req.params.keyId);
      const apiKey = await dbStorage.getApiKey(keyId);
      if (!apiKey) {
        return res.status(404).json({ message: "API key not found" });
      
      
      if (req.body.isActive === false) {
        // Deactivate the API key
        const updatedApiKey = await dbStorage.deactivateApiKey(keyId);
        return res.json(updatedApiKey);
      } else if (req.body.isActive === true) {
        // Reactivate the API key
        const updatedApiKey = await dbStorage.updateApiKey(keyId, { isActive: true });
        return res.json(updatedApiKey);
      
      
      // Update other properties
      const updatedApiKey = await dbStorage.updateApiKey(keyId, req.body);
      res.json(updatedApiKey);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.patch("/api/admin/users/:id", isBusinessAdmin, async (req, res) => {
    try {
      // Extract the fields we allow to be updated
      const {
        username, 
        email, 
        company, 
        credits, 
        role, 
        parentUserId,
        canPurchaseCredits,
        creditThreshold
      } = req.body;
      
      // Build update object with only defined values
      const updateData: Partial<User> = {};
      if (username !== undefined) updateData.username = username;
      if (email !== undefined) updateData.email = email;
      if (company !== undefined) updateData.company = company;
      if (credits !== undefined) updateData.credits = credits;
      if (role !== undefined) updateData.role = role;
      if (parentUserId !== undefined) updateData.parentUserId = parentUserId;
      if (canPurchaseCredits !== undefined) updateData.canPurchaseCredits = canPurchaseCredits;
      if (creditThreshold !== undefined) updateData.creditThreshold = creditThreshold;
      
      const userId = parseInt(req.params.id);
      const user = await dbStorage.updateUser(userId, updateData);
      
      if (!user) {
        return res.status(404).json({ message: "User not found" });
      
      
      // If credit purchase permission was changed, create a notification
      if (canPurchaseCredits !== undefined) {
        const { notificationService } = await import('./notifications');
        const adminName = req.user?.username || 'An administrator';
        
        // Notify the affected user
        await notificationService.createNotification(
          userId,
          `Your credit purchase ability has been ${canPurchaseCredits ? 'enabled' : 'disabled'} by ${adminName}`,
          canPurchaseCredits ? 'success' : 'warning',
          {
            relatedEntityType: 'user_setting',
            link: '/profile'
          
        );
      
      
      // If credit threshold was changed, create a notification
      if (creditThreshold !== undefined) {
        const { notificationService } = await import('./notifications');
        const adminName = req.user?.username || 'An administrator';
        
        // Notify the affected user
        await notificationService.createNotification(
          userId,
          `Your credit threshold has been ${creditThreshold === null ? 'removed' : `set to ${creditThreshold}`} by ${adminName}`,
          'info',
          {
            relatedEntityType: 'user_setting',
            link: '/profile'
          
        );
      
      
      res.json(user);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.delete("/api/admin/users/:id", isBusinessAdmin, async (req, res) => {
    try {
      const success = await dbStorage.deleteUser(parseInt(req.params.id));
      if (!success) {
        return res.status(404).json({ message: "User not found" });
      
      res.json({ message: "User deleted successfully" });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });
  
  // Admin request routes
  
  // Get all pending admin requests (business admins only)
  app.get("/api/admin/admin-requests", isBusinessAdmin, async (req, res) => {
    try {
      const pendingRequests = await dbStorage.getPendingAdminRequests();
      res.json(pendingRequests);
    } catch (error: any) {
      console.error("Error getting pending admin requests:", error);
      res.status(500).json({ message: error.message });
    
  });
  
  // Get pending admin requests (used for dashboard notification)
  app.get("/api/admin/requests/pending", isClientAdmin, async (req, res) => {
    try {
      const pendingRequests = await dbStorage.getPendingAdminRequests();
      res.json(pendingRequests);
    } catch (error: any) {
      console.error("Error fetching pending admin requests:", error);
      res.status(500).json({ message: error.message });
    
  });
  
  // Update admin request status (approve/reject)
  app.patch("/api/admin/admin-requests/:id", isBusinessAdmin, async (req, res) => {
    try {
      const id = parseInt(req.params.id);
      if (isNaN(id)) {
        return res.status(400).json({ message: "Invalid request ID" });
      
      
      const { status, notes } = req.body;
      if (!status) {
        return res.status(400).json({ message: "Status is required" });
      
      
      const updatedRequest = await dbStorage.updateAdminRequestStatus(
        id,
        status,
        req.user!.id,
        notes
      );
      
      if (!updatedRequest) {
        return res.status(404).json({ message: "Admin request not found" });
      
      
      // Send notification to the user about request status update
      try {
        // Get the user who requested admin privileges
        const user = await dbStorage.getUser(updatedRequest.userId);
        
        if (user && user.email) {
          const statusText = status === 'approved' ? 'approved' : 'rejected';
          const notificationMessage = `Your admin request has been ${statusText}`;
          const notificationType = status === 'approved' ? 'success' : 'info';
          
          // Create notification for the user
          await notificationService.createForUser(
            user.id,
            notificationMessage,
            notificationType as 'success' | 'info',
            {
              relatedEntityType: 'admin_request',
              relatedEntityId: updatedRequest.id,
              link: '/settings'
            
          );
          
          // Also send email notification
          if (process.env.SENDGRID_API_KEY) {
            await notificationService.sendEmailNotification(
              user.email,
              `API Manager: Admin Request ${statusText.toUpperCase()}`,
              `Your request for admin privileges has been ${statusText}.${notes ? ` Reviewer notes: ${notes}` : ''}`,
              notificationType as 'success' | 'info'
            );
          
          
          console.log(`Admin request status notification sent to user ${user.username}`);
        
      } catch (notifyError) {
        console.error("Error sending admin request status notification:", notifyError);
        // Continue with the response even if notification fails
      
      
      res.json(updatedRequest);
    } catch (error: any) {
      console.error("Error updating admin request:", error);
      res.status(500).json({ message: error.message });
    
  });
  
  // Get a user's admin requests (for the dashboard)
  app.get("/api/admin-requests", isAuthenticated, async (req, res) => {
    try {
      const requests = await dbStorage.getAdminRequestsByUserId(req.user!.id);
      res.json(requests);
    } catch (error: any) {
      console.error("Error getting user admin requests:", error);
      res.status(500).json({ message: error.message });
    
  });
  
  // Create a new admin request
  app.post("/api/admin-requests", isAuthenticated, async (req, res) => {
    try {
      // Check if user already has a pending request
      const userRequests = await dbStorage.getAdminRequestsByUserId(req.user!.id);
      const hasPendingRequest = userRequests.some(request => 
        request.status === 'pending'
      );
      
      if (hasPendingRequest) {
        return res.status(400).json({ 
          message: "You already have a pending admin request. Please wait for it to be processed."
        });
      
      
      // Check if user is already an admin
      if (req.user!.role === 'business_admin' || req.user!.role === 'client_admin') {
        return res.status(400).json({ 
          message: "You already have admin privileges."
        });
      
      
      const { reason } = req.body;
      if (!reason) {
        return res.status(400).json({ message: "Reason is required" });
      
      
      // Validate with the schema
      const validatedData = insertAdminRequestSchema.parse({
        userId: req.user!.id,
        reason,
        status: ADMIN_REQUEST_STATUS.PENDING,
        createdAt: new Date(),
        updatedAt: new Date()
      });
      
      const adminRequest = await dbStorage.createAdminRequest(validatedData);
      
      // Notify all business admins about the new request
      try {
        // Get the user's information to include in notification
        const user = await dbStorage.getUser(req.user!.id);
        
        if (user) {
          const requestLink = '/admin/requests';
          const notificationMessage = `New admin request from ${user.username}${user.company ? ` (${user.company})` : ''}`;
          
          // Send in-app and email notifications to all business admins
          await notificationService.notifyAdmins(
            notificationMessage,
            'info',
            {
              relatedEntityType: 'admin_request',
              relatedEntityId: adminRequest.id,
              link: requestLink
            
          );
          
          console.log(`Admin request notification sent for request ID ${adminRequest.id}`);
        
      } catch (notifyError) {
        console.error("Error sending admin request notifications:", notifyError);
        // Continue with the response even if notifications fail
      
      
      res.status(201).json(adminRequest);
    } catch (error: any) {
      console.error("Error creating admin request:", error);
      res.status(500).json({ message: error.message });
    
  });

  // Admin - Usage Statistics
  app.get("/api/admin/statistics/overview", isClientAdmin, async (req, res) => {
    try {
      let statistics = {};
      
      // Different stats for different admin roles
      if (req.user!.role === USER_ROLES.BUSINESS_ADMIN) {
        // Business admins see all stats
        const totalUsers = await dbStorage.getUserCount();
        const totalApiKeys = await dbStorage.getApiKeyCount();
        const totalTransactions = await dbStorage.getTransactionCount();
        const totalApiUsage = await dbStorage.getApiUsageCount();
        const totalRevenue = await dbStorage.getTotalRevenue();
        const activeDiscountCodes = await dbStorage.getActiveDiscountCodeCount();
        
        statistics = {
          totalUsers,
          totalApiKeys,
          totalTransactions,
          totalApiUsage,
          totalRevenue,
          activeDiscountCodes
        };
      } else if (req.user!.role === USER_ROLES.CLIENT_ADMIN) {
        // Client admins need filtered stats for their managed users
        
        // Get all users first and filter to find this admin's managed users
        const allUsers = await dbStorage.getAllUsers();
        const managedUserIds = allUsers
          .filter(user => user.parentUserId === req.user!.id || user.id === req.user!.id)
          .map(user => user.id);
        
        // Count of managed users (including self)
        const totalUsers = managedUserIds.length;
        
        // Count API keys for managed users
        let totalApiKeys = 0;
        let totalApiUsage = 0;
        
        // For each managed user, get their API keys and usage
        for (const userId of managedUserIds) {
          const userApiKeys = await dbStorage.getApiKeysByUserId(userId);
          totalApiKeys += userApiKeys.length;
          
          // API usage for this user
          const userApiUsage = await dbStorage.getApiUsage(userId);
          totalApiUsage += userApiUsage.length;
        
        
        // Client admins don't see revenue and discount codes stats
        statistics = {
          totalUsers,
          totalApiKeys,
          totalApiUsage,
          managedUserIds // Include this for other endpoints to use
        };
      
      
      res.json(statistics);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.get("/api/admin/statistics/transactions", isClientAdmin, async (req, res) => {
    try {
      // Get transaction statistics with pagination
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      
      // Different behaviors based on admin role
      if (req.user!.role === USER_ROLES.BUSINESS_ADMIN) {
        // Business admins see all transactions
        const transactions = await dbStorage.getTransactionsWithPagination(page, limit);
        const total = await dbStorage.getTransactionCount();
        
        res.json({
          data: transactions,
          pagination: {
            page,
            limit,
            total,
            totalPages: Math.ceil(total / limit)
          
        });
      } else if (req.user!.role === USER_ROLES.CLIENT_ADMIN) {
        // Client admins only see transactions for their managed users
        
        // First get all users managed by this admin
        const allUsers = await dbStorage.getAllUsers();
        const managedUserIds = allUsers
          .filter(user => user.parentUserId === req.user!.id || user.id === req.user!.id)
          .map(user => user.id);
        
        // Get all transactions for all users
        let allTransactions = [];
        for (const userId of managedUserIds) {
          const userTransactions = await dbStorage.getTransactions(userId);
          allTransactions = allTransactions.concat(userTransactions);
        
        
        // Sort by createdAt desc
        allTransactions.sort((a, b) => 
          new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime()
        );
        
        // Manual pagination
        const startIndex = (page - 1) * limit;
        const endIndex = startIndex + limit;
        const paginatedTransactions = allTransactions.slice(startIndex, endIndex);
        
        res.json({
          data: paginatedTransactions,
          pagination: {
            page,
            limit,
            total: allTransactions.length,
            totalPages: Math.ceil(allTransactions.length / limit)
          
        });
      
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.get("/api/admin/statistics/api-usage", isClientAdmin, async (req, res) => {
    try {
      // Get API usage statistics with pagination
      const page = parseInt(req.query.page as string) || 1;
      const limit = parseInt(req.query.limit as string) || 10;
      
      const apiUsage = await dbStorage.getApiUsageWithPagination(page, limit);
      const total = await dbStorage.getApiUsageCount();
      
      res.json({
        data: apiUsage,
        pagination: {
          page,
          limit,
          total,
          totalPages: Math.ceil(total / limit)
        
      });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  // Notifications are handled earlier in this file

  // Password reset request - initiates the reset process
  app.post('/api/password-reset/request', async (req, res) => {
    try {
      const { email } = req.body;
      
      if (!email) {
        return res.status(400).json({ message: 'Email is required' });
      
      
      // Find user by email
      const user = await dbStorage.getUserByEmail(email);
      
      // Always return success even if email not found for security
      // This prevents email enumeration attacks
      if (!user) {
        console.log(`Password reset requested for unknown email: ${email}`);
        return res.status(200).json({ 
          message: 'If an account with that email exists, a password reset link has been sent.' 
        });
      
      
      // In a real implementation, generate a token and store it
      // For demo purposes, we'll just log it and send a notification
      console.log(`Password reset requested for user: ${user.username} (${user.email})`);
      
      // Send email notification if SendGrid is configured
      if (process.env.SENDGRID_API_KEY) {
        await notificationService.sendEmailNotification(
          user.email,
          'API Manager: Password Reset Request',
          'You recently requested to reset your password. Click the link below to reset it. ' +
          'If you did not request a password reset, please ignore this email.',
          'info'
        );
      
      
      res.status(200).json({ 
        message: 'If an account with that email exists, a password reset link has been sent.' 
      });
    } catch (error: any) {
      console.error('Error in password reset request:', error);
      res.status(500).json({ message: 'An error occurred processing your request' });
    
  });

  // PayPal integration endpoints
  app.get("/paypal/setup", async (req, res) => {
    await loadPaypalDefault(req, res);
  });

  // Custom wrapper for PayPal order creation that checks if user can purchase credits
  app.post("/api/paypal/create-order", isAuthenticated, async (req, res) => {
    try {
      // First check if user is allowed to purchase credits
      const user = await dbStorage.getUser(req.user!.id);
      if (user && user.canPurchaseCredits === false) {
        return res.status(403).json({ 
          message: "Credit purchases are disabled for your account. Please contact your administrator."
        });
      
      
      // Get bundle information from request
      const { bundleId, discountCode } = req.body;
      
      if (!bundleId) {
        return res.status(400).json({ message: "Bundle ID is required" });
      
      
      const bundle = await dbStorage.getCreditBundle(bundleId);
      if (!bundle) {
        return res.status(404).json({ message: "Credit bundle not found" });
      
      
      // Calculate final price with discount if applicable
      let finalPrice = bundle.price;
      let appliedDiscount = null;
      
      if (discountCode) {
        const validationResult = await dbStorage.validateDiscountCode(discountCode, bundle.price);
        if (validationResult.isValid && validationResult.discountCode) {
          finalPrice = bundle.price - validationResult.discountAmount;
          appliedDiscount = {
            code: discountCode,
            discountAmount: validationResult.discountAmount,
            originalPrice: bundle.price,
            finalPrice: finalPrice
          };
        
      
      
      // Forward to PayPal with verified information
      req.body = {
        ...req.body,
        amount: finalPrice / 100, // Convert from cents to dollars for PayPal
        metadata: {
          bundleId: bundleId,
          userId: req.user!.id,
          discountCode: discountCode || null,
          credits: bundle.credits
        
      };
      
      // Forward to PayPal's order creation endpoint
      await createPaypalOrder(req, res);
    } catch (error: any) {
      console.error("Error creating PayPal order:", error);
      res.status(500).json({ message: error.message });
    
  });

  // Regular PayPal endpoints (keep these for backward compatibility)
  app.post("/paypal/order", async (req, res) => {
    // Request body should contain: { intent, amount, currency 
    await createPaypalOrder(req, res);
  });

  app.post("/paypal/order/:orderID/capture", isAuthenticated, async (req, res) => {
    try {
      // Get original response from PayPal
      const originalResponse = await capturePaypalOrder(req, res);
      
      // If payment was successful, add credits to user account
      if (originalResponse && originalResponse.status === "COMPLETED") {
        const metadata = originalResponse.metadata || {};
        const bundleId = metadata.bundleId;
        const userId = req.user!.id; // Use authenticated user ID
        const discountCode = metadata.discountCode;
        
        if (bundleId) {
          const bundle = await dbStorage.getCreditBundle(parseInt(bundleId));
          if (bundle) {
            // Add credits to user
            await dbStorage.addCredits(userId, bundle.credits);
            
            // Record the transaction
            await dbStorage.createTransaction({
              userId: userId,
              type: "purchase",
              amount: bundle.credits,
              description: `Purchased ${bundle.name} via PayPal`,
              apiKeyId: null,
              status: "success",
              metadata: {
                bundleId: bundle.id,
                discountCode: discountCode,
                paymentMethod: "paypal",
                orderId: req.params.orderID
              
            });
            
            // If discount code was used, increment its usage
            if (discountCode) {
              try {
                const discountCodeObj = await dbStorage.getDiscountCodeByCode(discountCode);
                if (discountCodeObj) {
                  await dbStorage.incrementDiscountCodeUsage(discountCodeObj.id);
                
              } catch (discountError) {
                console.error("Error updating discount code usage:", discountError);
                // Continue even if updating discount code fails
              
            
            
            // Send confirmation email
            const user = await dbStorage.getUser(userId);
            if (user) {
              try {
                await notificationService.sendCreditPurchaseConfirmation(
                  user,
                  bundle.credits,
                  bundle.price / 100, // Convert from cents to dollars
                  "PayPal"
                );
              } catch (emailError) {
                console.error("Error sending purchase confirmation email:", emailError);
                // Continue even if email fails
              
            
          
        
      
      
      return originalResponse;
    } catch (error: any) {
      console.error("Error processing PayPal capture:", error);
      return res.status(500).json({ error: error.message });
    
  });

  // Subscription-related endpoints
  app.get("/api/subscription-plans", async (req, res) => {
    try {
      const subscriptionPlans = await dbStorage.getSubscriptionPlans();
      res.json(subscriptionPlans);
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.get("/api/user-subscription", isAuthenticated, async (req, res) => {
    try {
      const userSubscription = await dbStorage.getUserSubscription(req.user!.id);
      res.json(userSubscription || { active: false });
    } catch (error: any) {
      res.status(500).json({ message: error.message });
    
  });

  app.post("/api/subscribe", isAuthenticated, async (req, res) => {
    try {
      const { planId, interval, paymentMethod } = req.body;
      
      if (!planId || !interval || !paymentMethod) {
        return res.status(400).json({ 
          message: "Missing required fields: planId, interval, or paymentMethod" 
        });
      
      
      // Validate interval
      if (!Object.values(SUBSCRIPTION_INTERVALS).includes(interval)) {
        return res.status(400).json({ 
          message: "Invalid interval. Must be one of: monthly, quarterly, annual" 
        });
      
      
      // Validate payment method
      if (!['stripe', 'paypal'].includes(paymentMethod)) {
        return res.status(400).json({ 
          message: "Invalid payment method. Must be 'stripe' or 'paypal'" 
        });
      
      
      // Get the subscription plan
      const plan = await dbStorage.getSubscriptionPlan(planId);
      if (!plan) {
        return res.status(404).json({ message: "Subscription plan not found" });
      
      
      // Create subscription based on payment method
      if (paymentMethod === 'stripe') {
        // Handle Stripe subscription
        if (!stripe) {
          return res.status(500).json({ 
            message: "Stripe is not configured. Please check server configuration." 
          });
        
        
        // Create or get Stripe customer
        let stripeCustomerId = req.user!.stripeCustomerId;
        if (!stripeCustomerId) {
          const customer = await stripe.customers.create({
            email: req.user!.email,
            name: req.user!.username,
            metadata: {
              userId: req.user!.id.toString()
            
          });
          stripeCustomerId = customer.id;
          await dbStorage.updateStripeCustomerId(req.user!.id, stripeCustomerId);
        
        
        // Get the appropriate price ID based on interval
        let stripePriceId;
        switch (interval) {
          case SUBSCRIPTION_INTERVALS.MONTHLY:
            stripePriceId = plan.stripePriceIdMonthly;
            break;
          case SUBSCRIPTION_INTERVALS.QUARTERLY:
            stripePriceId = plan.stripePriceIdQuarterly;
            break;
          case SUBSCRIPTION_INTERVALS.ANNUAL:
            stripePriceId = plan.stripePriceIdAnnual;
            break;
        
        
        if (!stripePriceId) {
          return res.status(400).json({ 
            message: `The selected plan doesn't support ${interval} billing` 
          });
        
        
        // Create a subscription
        const subscription = await stripe.subscriptions.create({
          customer: stripeCustomerId,
          items: [{ price: stripePriceId }],
          payment_behavior: 'default_incomplete',
          expand: ['latest_invoice.payment_intent'],
        });
        
        // Calculate subscription period
        const now = new Date();
        const currentPeriodStart = new Date(subscription.current_period_start * 1000);
        const currentPeriodEnd = new Date(subscription.current_period_end * 1000);
        
        // Create user subscription record
        const userSubscription = await dbStorage.createUserSubscription({
          userId: req.user!.id,
          planId,
          status: subscription.status,
          currentPeriodStart,
          currentPeriodEnd,
          cancelAtPeriodEnd: subscription.cancel_at_period_end,
          interval,
          stripeSubscriptionId: subscription.id,
        });
        
        // Return client secret for frontend to complete payment
        const invoice = subscription.latest_invoice as any;
        res.json({
          subscriptionId: subscription.id,
          clientSecret: invoice?.payment_intent?.client_secret,
          userSubscription
        });
      } else {
        // PayPal subscription handling would go here
        // For now, return a message that PayPal subscription is not yet implemented
        res.status(501).json({ 
          message: "PayPal subscription creation is not yet implemented" 
        });
      
    } catch (error: any) {
      console.error("Error creating subscription:", error);
      res.status(500).json({ message: error.message });
    
  });

  const httpServer = createServer(app);
  return httpServer;


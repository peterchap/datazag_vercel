/**
 * API Gateway for Database Access
 * 
 * This file creates a secure API server that sits between your Firebase-hosted frontend
 * and your PostgreSQL database. It handles authentication, authorization, and provides
 * endpoints for accessing and manipulating data.
 */

require('dotenv').config();
const express = require('express');
const cors = require('cors');
const { Pool } = require('pg');
const bcrypt = require('bcrypt');
const jwt = require('jsonwebtoken');
const rateLimit = require('express-rate-limit');

// Initialize Express app
const app = express();
const port = process.env.PORT || 3000;

// Configure middleware
app.use(express.json());

// Configure CORS
const allowedOrigins = process.env.ALLOWED_ORIGINS 
  ? process.env.ALLOWED_ORIGINS.split(',') 
  : ['http://localhost:5000'];

app.use(cors({
  origin: function(origin, callback) {
    // Allow requests with no origin (like mobile apps or curl requests)
    if (!origin) return callback(null, true);
    
    if (allowedOrigins.indexOf(origin) === -1) {
      const msg = 'The CORS policy for this site does not allow access from the specified Origin.';
      return callback(new Error(msg), false);
    }
    return callback(null, true);
  },
  credentials: true
}));

// Configure rate limiting
const limiter = rateLimit({
  windowMs: process.env.RATE_LIMIT_WINDOW_MS || 15 * 60 * 1000, // 15 minutes
  max: process.env.RATE_LIMIT_MAX_REQUESTS || 100, // Limit each IP to 100 requests per window
  standardHeaders: true, // Return rate limit info in the `RateLimit-*` headers
  message: 'Too many requests from this IP, please try again later'
});

// Apply rate limiting to all requests
app.use(limiter);

// Initialize database connection pool
if (!process.env.DATABASE_URL) {
  console.error('DATABASE_URL environment variable is required');
  process.exit(1);
}

console.log('Attempting to connect to database...');

// Parse connection string to extract components (for better diagnostics)
let dbConfig = {};
try {
  const dbUrl = new URL(process.env.DATABASE_URL);
  dbConfig = {
    host: dbUrl.hostname,
    port: parseInt(dbUrl.port) || 5432,
    database: dbUrl.pathname.slice(1),
    user: dbUrl.username,
    password: dbUrl.password,
    // Try connecting with and without SSL
    ssl: process.env.DB_USE_SSL === 'false' ? false : { rejectUnauthorized: false },
    // Connection tuning
    connectionTimeoutMillis: 10000,
    max: 10,
    idleTimeoutMillis: 30000
  };
  
  console.log('Database connection parameters:');
  console.log('- Host:', dbConfig.host);
  console.log('- Port:', dbConfig.port);
  console.log('- Database:', dbConfig.database);
  console.log('- SSL:', dbConfig.ssl ? 'Enabled' : 'Disabled');
} catch (err) {
  console.error('Error parsing DATABASE_URL:', err.message);
  console.log('Falling back to direct connection string');
  dbConfig = {
    connectionString: process.env.DATABASE_URL,
    ssl: process.env.DB_USE_SSL === 'false' ? false : { rejectUnauthorized: false },
    connectionTimeoutMillis: 10000,
    max: 10,
    idleTimeoutMillis: 30000
  };
}

// Create connection pool with parsed parameters or fallback to connection string
const pool = new Pool(dbConfig);

// Test database connection
pool.query('SELECT NOW()', (err, result) => {
  if (err) {
    console.error('Database connection error:', err);
    console.error('Error details:', err.message);
    console.error('Error code:', err.code);
    
    // Don't exit immediately - let's try to diagnose the issue
    console.log('Checking DATABASE_URL format...');
    try {
      // Parse but don't log sensitive credentials
      const url = new URL(process.env.DATABASE_URL);
      console.log('Database connection info:');
      console.log('- Protocol:', url.protocol);
      console.log('- Host:', url.hostname);
      console.log('- Port:', url.port);
      console.log('- Database:', url.pathname.substring(1));
      console.log('- SSL Mode:', url.searchParams.get('sslmode') || 'default');
    } catch (parseErr) {
      console.error('Invalid DATABASE_URL format:', parseErr.message);
    }
    
    process.exit(1);
  } else {
    console.log('Database connected successfully at', result.rows[0].now);
  }
});

// JWT Authentication middleware
const authenticateToken = (req, res, next) => {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];
  
  if (!token) return res.status(401).json({ message: 'Authentication required' });
  
  jwt.verify(token, process.env.JWT_SECRET, (err, user) => {
    if (err) return res.status(403).json({ message: 'Invalid or expired token' });
    req.user = user;
    next();
  });
};

// Service API key middleware for internal services
const authenticateServiceKey = (req, res, next) => {
  const apiKey = req.headers['x-api-service-key'];
  
  if (!apiKey || apiKey !== process.env.API_SERVICE_KEY) {
    return res.status(403).json({ message: 'Invalid service API key' });
  }
  
  next();
};

// Role-based authorization middleware
const authorize = (roles = []) => {
  return (req, res, next) => {
    if (!req.user) return res.status(401).json({ message: 'Authentication required' });
    
    if (roles.length && !roles.includes(req.user.role)) {
      return res.status(403).json({ message: 'Insufficient permissions' });
    }
    
    next();
  };
};

// Health check endpoint
app.get('/health', (req, res) => {
  res.status(200).json({ status: 'ok' });
});

// Authentication endpoints
app.post('/api/login', async (req, res) => {
  try {
    const { email, password } = req.body;
    
    if (!email || !password) {
      return res.status(400).json({ message: 'Email and password are required' });
    }
    
    // Get user from database
    const userResult = await pool.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );
    
    const user = userResult.rows[0];
    
    if (!user) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }
    
    // Check password
    const validPassword = await bcrypt.compare(password, user.password);
    
    if (!validPassword) {
      return res.status(401).json({ message: 'Invalid email or password' });
    }
    
    // Create JWT token
    const token = jwt.sign(
      { id: user.id, role: user.role },
      process.env.JWT_SECRET,
      { expiresIn: '2d' }
    );
    
    // Return user data and token
    const { password: _, ...userWithoutPassword } = user;
    res.status(200).json({
      token,
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/register', async (req, res) => {
  try {
    const { firstName, lastName, email, password, company } = req.body;
    
    // Validate required fields
    if (!firstName || !lastName || !email || !password) {
      return res.status(400).json({ message: 'All fields are required' });
    }
    
    // Check if user already exists
    const existingUser = await pool.query(
      'SELECT * FROM users WHERE email = $1',
      [email]
    );
    
    if (existingUser.rows.length > 0) {
      return res.status(409).json({ message: 'User with this email already exists' });
    }
    
    // Hash password
    const salt = await bcrypt.genSalt(10);
    const hashedPassword = await bcrypt.hash(password, salt);
    
    // Insert new user
    const result = await pool.query(
      `INSERT INTO users (first_name, last_name, email, password, company, role, credits) 
       VALUES ($1, $2, $3, $4, $5, $6, $7) RETURNING *`,
      [firstName, lastName, email, hashedPassword, company || '', 'USER', 0]
    );
    
    const newUser = result.rows[0];
    
    // Create token
    const token = jwt.sign(
      { id: newUser.id, role: newUser.role },
      process.env.JWT_SECRET,
      { expiresIn: '2d' }
    );
    
    // Return user data and token
    const { password: _, ...userWithoutPassword } = newUser;
    res.status(201).json({
      token,
      user: userWithoutPassword
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// User endpoints
app.get('/api/user', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT id, first_name, last_name, email, company, credits, role FROM users WHERE id = $1',
      [req.user.id]
    );
    
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Transform to match frontend schema
    const user = result.rows[0];
    res.status(200).json({
      id: user.id,
      firstName: user.first_name,
      lastName: user.last_name,
      username: `${user.first_name} ${user.last_name}`,
      email: user.email,
      company: user.company,
      credits: user.credits,
      role: user.role
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

app.patch('/api/profile', authenticateToken, async (req, res) => {
  try {
    const { email, company } = req.body;
    const updates = {};
    const params = [req.user.id];
    
    // Build dynamic update query
    let updateQuery = 'UPDATE users SET ';
    let paramIndex = 2;
    
    if (email) {
      updates.email = email;
      updateQuery += `email = $${paramIndex}, `;
      params.push(email);
      paramIndex++;
    }
    
    if (company !== undefined) {
      updates.company = company;
      updateQuery += `company = $${paramIndex}, `;
      params.push(company);
      paramIndex++;
    }
    
    // Remove trailing comma and space
    updateQuery = updateQuery.slice(0, -2);
    
    // Add WHERE clause and RETURNING
    updateQuery += ' WHERE id = $1 RETURNING id, first_name, last_name, email, company, credits, role';
    
    // If no updates, return current user
    if (Object.keys(updates).length === 0) {
      const result = await pool.query(
        'SELECT id, first_name, last_name, email, company, credits, role FROM users WHERE id = $1',
        [req.user.id]
      );
      
      const user = result.rows[0];
      return res.status(200).json({
        id: user.id,
        firstName: user.first_name,
        lastName: user.last_name,
        username: `${user.first_name} ${user.last_name}`,
        email: user.email,
        company: user.company,
        credits: user.credits,
        role: user.role
      });
    }
    
    // Perform update
    const result = await pool.query(updateQuery, params);
    
    if (result.rows.length === 0) {
      return res.status(404).json({ message: 'User not found' });
    }
    
    // Transform to match frontend schema
    const user = result.rows[0];
    res.status(200).json({
      id: user.id,
      firstName: user.first_name,
      lastName: user.last_name,
      username: `${user.first_name} ${user.last_name}`,
      email: user.email,
      company: user.company,
      credits: user.credits,
      role: user.role
    });
  } catch (error) {
    console.error('Update profile error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// API Key endpoints
app.get('/api/api-keys', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM api_keys WHERE user_id = $1 ORDER BY created_at DESC',
      [req.user.id]
    );
    
    res.status(200).json(result.rows);
  } catch (error) {
    console.error('Get API keys error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

app.post('/api/api-keys', authenticateToken, async (req, res) => {
  try {
    const { name } = req.body;
    
    if (!name) {
      return res.status(400).json({ message: 'API key name is required' });
    }
    
    // Generate a unique API key
    const key = `api_${req.user.id}_${Date.now()}_${Math.random().toString(36).substring(2, 15)}`;
    
    // Insert new API key
    const result = await pool.query(
      `INSERT INTO api_keys (user_id, key, name, active) 
       VALUES ($1, $2, $3, $4) RETURNING *`,
      [req.user.id, key, name, true]
    );
    
    res.status(201).json(result.rows[0]);
  } catch (error) {
    console.error('Create API key error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

app.delete('/api/api-keys/:id', authenticateToken, async (req, res) => {
  try {
    const keyId = req.params.id;
    
    // Verify the API key belongs to the user
    const keyCheck = await pool.query(
      'SELECT * FROM api_keys WHERE id = $1 AND user_id = $2',
      [keyId, req.user.id]
    );
    
    if (keyCheck.rows.length === 0) {
      return res.status(404).json({ message: 'API key not found' });
    }
    
    // Deactivate the API key (soft delete)
    await pool.query(
      'UPDATE api_keys SET active = false WHERE id = $1',
      [keyId]
    );
    
    res.status(200).json({ message: 'API key deactivated successfully' });
  } catch (error) {
    console.error('Deactivate API key error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Credit and transaction endpoints
app.get('/api/credit-bundles', async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM credit_bundles WHERE active = true ORDER BY credits ASC'
    );
    
    res.status(200).json(result.rows);
  } catch (error) {
    console.error('Get credit bundles error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

app.get('/api/transactions', authenticateToken, async (req, res) => {
  try {
    const result = await pool.query(
      'SELECT * FROM transactions WHERE user_id = $1 ORDER BY created_at DESC',
      [req.user.id]
    );
    
    res.status(200).json(result.rows);
  } catch (error) {
    console.error('Get transactions error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// API usage endpoint (for FastAPI service)
app.post('/api/usage', authenticateServiceKey, async (req, res) => {
  try {
    const { apiKeyId, userId, queryComplexity, rowsProcessed, computeTimeMs, dataTransferredBytes } = req.body;
    
    // Validate required fields
    if (!apiKeyId || !userId) {
      return res.status(400).json({ message: 'API key ID and user ID are required' });
    }
    
    // Calculate credits to deduct based on the metrics
    let creditsToDeduct = 0;
    
    // Simple calculation based on complexity
    switch (queryComplexity) {
      case 'low':
        creditsToDeduct = 1;
        break;
      case 'medium':
        creditsToDeduct = 3;
        break;
      case 'high':
        creditsToDeduct = 5;
        break;
      case 'very_high':
        creditsToDeduct = 10;
        break;
      default:
        creditsToDeduct = 1;
    }
    
    // Additional factors
    if (rowsProcessed) {
      creditsToDeduct += Math.ceil(rowsProcessed / 10000);
    }
    
    if (computeTimeMs) {
      creditsToDeduct += Math.ceil(computeTimeMs / 5000);
    }
    
    if (dataTransferredBytes) {
      creditsToDeduct += Math.ceil(dataTransferredBytes / (1024 * 1024));
    }
    
    // Begin transaction
    const client = await pool.connect();
    
    try {
      await client.query('BEGIN');
      
      // Record API usage
      await client.query(
        `INSERT INTO api_usage (api_key_id, user_id, query_complexity, rows_processed, compute_time_ms, data_transferred_bytes, credits_used)
         VALUES ($1, $2, $3, $4, $5, $6, $7)`,
        [apiKeyId, userId, queryComplexity, rowsProcessed, computeTimeMs, dataTransferredBytes, creditsToDeduct]
      );
      
      // Update user's credit balance
      const userResult = await client.query(
        'UPDATE users SET credits = credits - $1 WHERE id = $2 RETURNING credits',
        [creditsToDeduct, userId]
      );
      
      if (userResult.rows.length === 0) {
        await client.query('ROLLBACK');
        return res.status(404).json({ message: 'User not found' });
      }
      
      await client.query('COMMIT');
      
      res.status(200).json({
        creditsDeducted: creditsToDeduct,
        remainingCredits: userResult.rows[0].credits
      });
    } catch (error) {
      await client.query('ROLLBACK');
      throw error;
    } finally {
      client.release();
    }
  } catch (error) {
    console.error('Record API usage error:', error);
    res.status(500).json({ message: 'Server error' });
  }
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error('Unhandled error:', err);
  res.status(500).json({ message: 'An unexpected error occurred' });
});

// Start the server
app.listen(port, () => {
  console.log(`API Gateway running on port ${port}`);
});

// Graceful shutdown
process.on('SIGTERM', () => {
  console.log('SIGTERM received, shutting down gracefully');
  pool.end();
  process.exit(0);
});

process.on('SIGINT', () => {
  console.log('SIGINT received, shutting down gracefully');
  pool.end();
  process.exit(0);
});